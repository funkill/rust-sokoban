# Настройка проекта

Давайте установим [rustup](https://www.rust-lang.org/tools/install), который установит нам Rust его компилятор. Теперь проверим, что всё корректно установлено, используя следующие две команды. Версии не так важны, так что можете не беспокоиться, если у вас будет другая.

```
$ rustc --version
rustc 1.40.0
$ cargo --version
cargo 1.40.0
```

## Создание проекта

Cargo - пакетный менеджер Rust, который мы будем использовать для создания проекта нашей игры. Перейдите в директорию, где она будет жить, и выполните следующую команду, которая создаст новый проект с названием `rust-sokoban`.

```
$ cargo init rust-sokoban
```

После работы команды, вы должны увидеть следующую структуру директорий:

```
├── src
│   └── main.rs
└── Cargo.toml
```

Теперь в этой директории мы можем запустить `cargo run` и должны увидеть что-то похожее:

```
$ cargo run
   Compiling rust-sokoban v0.1.0
    Finished dev [unoptimized + debuginfo] target(s) in 1.30s
     Running `../rust-sokoban/target/debug/rust-sokoban`
Hello, world!
```

## Создание игры

Настало время превратить наш базовый "Hello, World!" в игру! Мы будем использовать [ggez](https://ggez.rs/) - один из популярных 2D движков для создания игр.

Помните файл `Cargo.toml`, который мы видели в нашей директории? Этот файл используется для управления зависимостями, так что если мы захотим использовать какой-нибудь из пакетов, мы должны добавить его туда. Давайте добавим [ggez](https://github.com/ggez/ggez), как одну из наших зависимостей.

> ***ЕЩЁ:*** узнать больше о Cargo и toml-файлах можно [здесь](https://doc.rust-lang.org/book/ch01-03-hello-cargo.html).

```toml
[dependencies]
ggez = "0.5.1"
```

Теперь снова запустим команду `cargo run` и увидим что-то похожее. Она будет работать чуть дольше, чем обычно, так как она загружает новые зависимости с [crates.io](https://crates.io), затем компилирует их и в итоге линкует с нашей библиотекой.

```
cargo run
    Updating crates.io index
    Downloaded ....
    ....
    Compiling ....
    ....
    Finished dev [unoptimized + debuginfo] target(s) in 2m 15s
    Running `.../rust-sokoban/target/debug/rust-sokoban`
    Hello, world!
```

> ***Обратите внимание:*** если вы используете Ubuntu, то возможно вам потребуется установить некоторые дополнительные системные зависимости. Если этот шаг потерпел неудачу и вы видите ошибки, связанные с `alsa` и `libudev`, то установите их при помощи команды `sudo apt-get install libudev-dev libasound2-dev`.

Теперь давайте используем `ggez` в главном файле и настроим окно. Это лишь простейший пример программы на `ggez`, в которой создаётся окно и больше ничего. Скопируйте это в  `main.rs` и запустите.

```rust
{{#include ../../../code/rust-sokoban-c01-01/src/main.rs}}
```

Вы должны увидеть что-то похожее.

![Screenshot](./images/window.png)

## Базовые концепции и синтаксис

Теперь, когда мы имеем базовое окно, давайте погрузимся в имеющийся у нас код и поймём основные концепции и синтаксис Rust.

### Импортирование

Эта концепция может быть знакома вам по другим языкам, которые вы можете знать. Для прокидывания типов и пространств имён в область видимости из наших зависимостей (пакетов) мы используем слово `use`.

```rust
// это импортирует `conf`, `event`, `Context` и `GameResult` из пакета ggez
{{#include ../../../code/rust-sokoban-c01-01/src/main.rs:1}}
```

### Объявление структуры

```rust
{{#include ../../../code/rust-sokoban-c01-01/src/main.rs:4:7}}
```

> ***ЕЩЁ:*** узнать больше о структурах вы можете [здесь](https://doc.rust-lang.org/book/ch05-00-structs.html).

### Реализация трейта

В других языках аналогом трейтов являются интерфейсы, которые позволяют нам привязывать какому-либо типу определённое поведение. В нашем случае, мы хотим реализовать трейт `EventHandler` и дать его поведение нашей структуре `Game`.

```rust
{{#include ../../../code/rust-sokoban-c01-01/src/main.rs:9:23}}
```

> ***ЕЩЁ:*** узнать больше о трейтах вы можете [здесь](https://doc.rust-lang.org/book/ch10-02-traits.html).

### Функции

Также мы изучим, как в Rust объявляются функции.

```rust
{{#include ../../../code/rust-sokoban-c01-01/src/main.rs:14:17}}
```

Вам может быть интересно, что означает `self`. В данном случае `self` означает, что функция `update` является функцией-членом, т.е. принадлежит экземпляру структуры `Game` и не может быть вызвана в статическом контексте.

> ***ЕЩЁ:*** узнать больше о функциях вы можете [здесь](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html).

### `mut`-синтаксис

Ещё вы можете задаться вопросом, что значит `&mut` в `&mut self` функции `update`. Изменяемость объекта просто говорит можно ли изменять его или нет. Ознакомьтесь со следующим примером объявления переменных.

```rust
let a = 10; // `a` не может быть изменена, так как она не объявлена как изменяемая
let mut b = 20; // `b` может измениться, так как она объявлена изменяемой
```

Теперь вернёмся к функции `update`. Если `mut` используется вместе с `self`, то оно ссылается на экземпляр структуры, к которой относится функция. Возьмём другой пример:

```rust
// Простая структура `X` с переменной `num` внутри
struct X {
    num: u32
}

// Блок реализации для `X`
impl X {
    fn a(&self) { self.num = 5 }
    // `a` не может изменить экземпляр структуры `X` так как
    // используется `&self`. Это не скомпилируется

    fn b(&mut self) { self.num = 5 }
    // `b` может изменять экземпляр структуры `X` так как
    // используется `&mut self`. Эта часть скомпилируется
}
```

> ***ЕЩЁ:*** узнать больше про изменяемость вы можете [здесь](https://web.mit.edu/6.005/www/fa15/classes/09-immutability/) (в этой лекции используется Java, но эти концепции можно применить к любым языкам), и прочитать больше о переменных и изменяемости в Rust можно [здесь](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html).

После небольшого введения в синтаксис Rust, мы готовы двигаться дальше. Увидимся в следующей главе!

> ***КОД:*** увидеть весь код из данной главы можно [здесь](https://github.com/iolivia/rust-sokoban/tree/master/code/rust-sokoban-c01-01).

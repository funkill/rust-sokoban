# Перемещение коробок

В предыдущей главе мы подарили нашему игроку свободу движений, но он пока не умеет взаимодействовать с окружением и проходит через стены и коробки. В этом разделе мы добавим ещё немного логики для того, чтобы игрок понимал, куда и как ему можно перемещаться.

## Компоненты передвижения

Для начала нам нужно немного доработать наш код. Если вы помните, в предыдущей главе нас заботило только то, куда должен двигаться игрок, — теперь же нам нужно двигать ещё и коробки. Кроме того, в будущем мы можем захотеть добавить и другие виды перемещаемых объектов, поэтому давайте попробуем соорудить что-нибудь, держа это в уме. Что мы сделаем согласно духу ECS? Мы создадим компоненты-маркеры, которые будут подсказывать нам, какие сущности можно перемещать, а какие нельзя. Например, игроки и коробки перемещаемы, а стены — нет. Места для коробок к этой классификации, конечно, относиться не будут: с одной стороны они не двигаются, а с другой — они не должны затрагивать перемещение игрока. Поэтому места для коробок не будут иметь ни одного маркера, ни второго.

Ниже описаны два наших новых компонента. Здесь нет ничего такого, чего мы бы уже не знали, — за исключением пары деталей:

- Мы используем `NullStorage`, что немного более эффективно, чем `VecStorage`, потому что у этих компонентов нет никаких полей — они используются только в качестве маркеров.
- Мы реализуем `Default`, потому что это необходимо для использования `NullStorage`.
- Оба этих компонента мы добавляем в функцию `register_components`.

```rust
{{#include ../../../code/rust-sokoban-c02-03/src/main.rs:55:62}}

{{#include ../../../code/rust-sokoban-c02-03/src/main.rs:250:259}}
```

После этого мы добавляем:

- `with(Movable)` — игрокам и коробкам,
- `with(Immovable)` — стенам,
- и ничего не делаем с полом и местами для коробок (как уже ранее упоминалось, они не должны быть частью нашей системы движения по причине того, что никак на неё не влияют).

```rust
{{#include ../../../code/rust-sokoban-c02-03/src/main.rs:266:321}}
```

## Ограничения движений

Теперь давайте придумаем несколько примеров, чтобы проиллюстрировать ограничения для движений. Это поможет нам понять, как мы должны изменить реализацию системы ввода, чтобы использовать маркеры `Movable` и `Immovable` правильно.

Сценарии:

1. `(player, floor)` и нажата клавиша `RIGHT` -&gt; игрок должен сдвинуться вправо.
2. `(player, wall)` и нажата клавиша `RIGHT` -&gt; игрок не должен двигаться вправо.
3. `(player, box, floor)` и нажата клавиша `RIGHT` -&gt; игрок должен сдвинуться вправо, коробка тоже должна сдвинуться вправо.
4. `(player, box, wall)` и нажата клавиша `RIGHT` -&gt; игрок и коробка должны оставаться на месте.
5. `(player, box, box, floor)` и нажата клавиша `RIGHT` -&gt; игрок и обе коробки должны сдвинуться вправо.
6. `(player, box, box, wall)` и нажата клавиша `RIGHT` -&gt; игрок и обе коробки должны оставаться на месте.

Основываясь на этом, мы можем сделать несколько наблюдений:

- Обнаружение перемещения и столкновений должно происходить для всех объектов одновременно. Возьмём сценарий 6 в качестве примера: если мы будем обрабатывать один объект за раз, мы сначала сдвинем игрока, затем первую коробку, а на второй мы поймём, что её мы сдвинуть не можем, — и нам придётся отменять все предыдущие изменения, что, конечно, неправильно. Поэтому для каждого ввода мы должны понимать, какие объекты участвуют в перемещении, и на основании этого уже решать, возможно оно или нет.
- Группа перемещаемых объектов вместе с пустым местом может двигаться (пустое место в этом случае означает что-то, что не относится к перемещаемым или неперемещаемым сущностям).
- Группа перемещаемых сущностей вместе с неперемещаемой двигаться не может.
- Несмотря на то, что все сценарии были написаны для движения вправо, эти правила должны работать с любым перемещением, а нажатая клавиша должна влиять только на то, как именно мы находим всю группу.

Учитывая всё вышесказанное, начнём реализовывать логику. Давайте подумаем над частями, которые нам нужны. Вот некоторые идеи для старта:

1. **Нужно найти все подвижные и неподвижные сущности** — так мы сможем понять, участвуют они в движении или нет.
2. **Понять, в какую сторону двигаться, основываясь на нажатой клавише** — мы сделали нечто похожее в прошлом разделе: просто немного +1/-1 операций, основанных на перечислении клавиш.
3. **Пройти через все позиции между игроком и концом карты** по конкретной оси, основываясь на направлении. Например, если мы двигаемся вправо, то нам нужно пройти от координаты игрока по оси x — `player.x` до ширины карты — `map_width`, если мы двигаемся вверх — от 0 до `player.y`.
4. **Для каждой сущности в этой последовательности** нам нужно:
    - если сущность перемещаема — запомнить её и продолжить,
    - если сущность неперемещаема — остановиться и ничего не перемещать,
    - если сущность не является ни той, ни другой — переместить все сущности, которые мы запомнили ранее.

Ниже — новая реализация системы ввода. Она довольно громоздкая, но она стоит того:

```rust
{{#include ../../../code/rust-sokoban-c02-03/src/main.rs:113:197}}
```

Теперь, если мы запустим код, мы увидим, что игра работает как надо! Мы больше не можем проходить через стены — зато можем двигать коробки, которые остановятся, если упрутся в стену.

![Moving player](https://github.com/funkill/rust-sokoban/blob/master/books/ru/src/images/movement.gif?raw=true)

Полный код находится ниже:

```rust
{{#include ../../../code/rust-sokoban-c02-03/src/main.rs}}
```

> ***КОД:*** Увидеть весь код из данной главы можно [здесь](https://github.com/iolivia/rust-sokoban/tree/master/code/rust-sokoban-c02-03).
